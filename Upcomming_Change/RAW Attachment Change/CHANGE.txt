Zielbild
	•	RAW immer behalten: Vollständige RFC822-Nachricht (inkl. Header, MIME-Boundaries, Body) unverändert speichern – Grundlage für Re-Parsing/Forensik.
	•	Einmalig robust parsen: MIME nur einmal dekodieren, dabei Parts korrekt identifizieren, Anhänge separat extrahieren und den anzeigbaren Body (HTML/Text) bereinigen.
	•	Attachments getrennt verwalten: Metadaten in der DB, Bytes in einem dedizierten Blob-Store/Filesystem (mit Hash/Dedup), verlinkt über message_id + part_id.
	•	Inline-Referenzen stabil auflösen: cid:-Links in HTML auf interne URLs mappen, die die passende Attachment-Ressource liefern.
	•	UI arbeitet nur mit „finalisierten“ Inhalten: MessageDetailView rendert fertiges HTML/Text; ein „Technische Ansicht“-Toggle zeigt RAW (keine erneute Verarbeitung).

1) Netzwerk/Fetch – nur so viel laden wie nötig
	1.	IMAP BODYSTRUCTURE abrufen und Parts sichten, bevor du Bytes ziehst. BODYSTRUCTURE ist serverseitig aus RFC5322/MIME berechnet und liefert Typen, Encodings, Größen, Disposition, Parameter usw.  ￼
	2.	Gezielt per Section/Partial fetchen: Für Body (text/plain, text/html) und für Attachments jeweils BODY.PEEK[<section>] nutzen; große Anhänge per Byte-Ranges nachladen (IMAP partial fetch). Das reduziert Traffic und UI-Latenz spürbar.  ￼

2) Parsing – korrekt nach MIME & Disposition

Beim MIME-Parse hältst du dich an diese Grundsätze:
	•	Content-Disposition: attachment vs. inline korrekt auswerten; filename bevorzugen. (Viele UAs waren historisch inkonsistent – also tolerant sein.)  ￼
	•	Parameter-Encoding: RFC2231 für fortgesetzte/UTF-8-Parameter (filename*= …) und Header-Encoded-Words beachten (Dateinamen!).  ￼
	•	Inline-Bilder: Content-ID/cid: gemäß RFC2392 behandeln – HTML-<img src="cid:..."> muss auf den passenden Part auflösen.  ￼

Empfehlung Library (iOS/Swift): Für IMAP und MIME Parsing ist MailCore2 auf iOS gut erprobt (IMAP, Fetch, Attachment-Download, Part-Baum). Alternativ auf niedriger Ebene libetpan.  ￼

3) Datenmodell – klar getrennte Schichten

messages (pro RFC822-Mail)
	•	id (PK)
	•	account_id, mailbox, uid (IMAP)
	•	raw_rfc822_blob_id (Zeiger in Blob-Store)
	•	from, to, subject, date, Flags …
	•	has_attachments (bool), size_total

mime_parts (strukturierter MIME-Baum)
	•	id (PK), message_id (FK)
	•	part_id (IMAP Section path, z. B. 1.2), parent_part_id
	•	media_type (z. B. image/png), charset, transfer_encoding
	•	disposition (inline/attachment/NULL)
	•	filename_original, filename_normalized
	•	content_id (für cid:), content_md5/sha256 (falls mitgeliefert/selbst berechnet)
	•	size_octets (laut Server), bytes_stored (real)
	•	is_body_candidate (bool) – z. B. text/html/text/plain
	•	blob_id (nur wenn wir Bytes abgelegt haben)

attachments (Sicht auf echte Dateien)
	•	id (PK), message_id (FK), mime_part_id (FK)
	•	storage_key (Pfad/Objektschlüssel), hash_sha256 (Dedup-Key)
	•	filename, media_type, disposition, content_id
	•	inline_referenced (bool), virus_scanned (enum), status

render_cache (fertiger Anzeigeinhalt)
	•	message_id (PK)
	•	html_rendered (sanitized, cid-Links -> App-URLs)
	•	text_rendered
	•	generated_at, generator_version

blob_store
	•	Filesystem (hierarchische Pfade nach Hash, z. B. /aa/bb/<hash>), oder S3-kompatibler Object-Store. Hash-basierte Dedup/Eindeutigkeit.

4) Verarbeitungspipeline (idempotent)
	1.	Fetch Phase
	•	BODYSTRUCTURE holen → mime_parts-Metadaten anlegen.
	•	Entscheiden, welche Parts jetzt gebraucht werden (HTML/Text, alle inline mit cid-Referenz).
	•	Bytes je Part gezielt laden, Transfer-Encoding korrekt dekodieren (Base64, QP), Charset normalisieren.
	2.	Attachment-Phase
	•	Für jeden Part mit disposition=attachment und für inline-Medien (Bilder) die Bytes in den Blob-Store schreiben, Hash bilden, attachments/mime_parts.blob_id füllen.
	•	Für sehr große Parts: streamend speichern (Range-Fetch).
	3.	HTML-Finalisierung
	•	Den besten Body-Kandidat wählen: multipart/alternative → HTML bevorzugen, Text fallback.
	•	cid:-URLs im HTML umschreiben auf interne Routen wie /mail/<message_id>/cid/<content_id>; diese Route liefert das passende Attachment (mit Content-Type, ETag aus Hash).  ￼
	•	Sanitizing (XSS, remote loads blocken, exzessive <style>/script> entfernen).
	4.	Persistenz
	•	render_cache schreiben (HTML/Text).
	•	RAW unverändert ablegen (Blob-Store) + Referenz in messages.raw_rfc822_blob_id.
	5.	Re-Parse/Invalidierung
	•	generator_version erhöhen, wenn Parser/Regeln sich ändern.
	•	Re-Parse ist idempotent: Vorhandene Blobs via Hash wiederverwenden, render_cache neu schreiben.

5) UI/UX-Logik (dein Toggle)
	•	Normale Ansicht (HTML/Text): rendert nur render_cache.
	•	Technische Ansicht: zeigt RAW (aus Blob-Store streamen).
	•	Wechsel RAW→Normal triggert keine Neuverarbeitung – außer du hast render_cache invalidiert (z. B. Parser-Update). Dein im Screenshot gezeigter „Re-Process“ hat dann einen klaren Anlass, nicht bei jedem Öffnen.

6) Sicherheit & Compliance
	•	AV-Scan/Content-Sniffing der Anhänge (z. B. ClamAV).
	•	Zip-Bomb-Schutz: rekursive Entpacklimits, Ratio-Limits.
	•	MIME-Robustheit: toleranter Parser – echte Mails verletzen oft RFCs; bekannte Kantenfälle behandeln (falsche Header, kaputte Boundaries). Beispiele aus libetpan-Bugtracker zeigen, dass Parser hart getestet werden sollten.  ￼
	•	I18N-Dateinamen: RFC2231/2047 korrekt decodieren; Fallbacks definieren.  ￼
	•	Content-Disposition respektieren, aber pragmatisch bleiben (Thunderbird & Co. sind teils abweichend).  ￼

7) Serving der Attachments
	•	Signed URLs/Token pro Benutzer/Session.
	•	HTTP Caching mit ETag=SHA256, Content-Type wie im Part.
	•	Inline: Content-Disposition: inline; Download: attachment; filename="..." (HTTP, aber die Semantik entspricht MIME; auf UTF-8/2231 achten).  ￼

8) Schrittweise Migration deiner aktuellen Kette

Nach deinen Skizzen passiert das MIME-Cleaning aktuell zu spät und wird doppelt angeworfen. Vorschlag:
	1.	IMAP → MailTransportStubs: nur Header + BODYSTRUCTURE und selektive Section-Fetches.
	2.	MIMEParser (einmal): Parts in mime_parts, Bytes für notwendige Parts; Attachments sofort abtrennen und speichern.
	3.	BodyContentProcessor (einmal): nur finale HTML/Text-Aufbereitung + cid-Rewrite.
	4.	DB: rawBody → Blob-Store, render_cache → DB, Attachments/Blobs separat.

9) Praxisdetails (die gern vergessen werden)
	•	S/MIME/PGP Parts als Attachments führen (z. B. smime.p7s), optionale Verifikation (später).  ￼
	•	MD5/SHA256 auf den dekodierten Bytes bilden, nicht auf Base64-Text.
	•	Heuristik Body-Wahl: multipart/related + multipart/alternative korrekt auflösen (HTML + zugehörige Inline-Parts).
	•	Throttling/Limits: Maximalgröße pro Attachment/Message, Abbruch mit sauberem UI-Hint.
	•	Rechtslage: Logging/Downloads der Attachments ggf. in Audit-Trail.

Aufgaben der Implemenmtierung:

	1.	Die Änderungsdateien enthalten den Code, der umgesetzt werden muss.
	2.	Vor jeder Änderung wird geprüft, ob eine Datei mit dem angegebenen Hauptnamen existiert.
	3.	Existiert die Datei, wird ihr aktueller Inhalt analysiert und es wird ausschließlich geprüft, ob die beschriebenen Änderungen bereits enthalten sind oder implementiert werden müssen.
	4.	Es werden keine Testdateien erstellt.
	5.	Neue Dateien werden ausschließlich dann angelegt, wenn sie in den Vorgaben ausdrücklich als neu definiert sind.
	6.	Neue Dateien werden im Bereich NewFile abgelegt.
	7.	Es werden keine Change- oder Dokumentationsdateien erzeugt.
	8.	Die gelieferten Änderungsdateien enthalten jeweils konkrete Code-Erweiterungen oder -Anpassungen. Diese Inhalte werden in bestehende Dateien integriert, ohne vorhandenen Code zu entfernen, sofern dies nicht ausdrücklich gefordert ist. Es werden keine neuen Dateien basierend auf alten Phase-Bezeichnungen oder Datei-Suffixen erzeugt.
	9.	Es werden nur Dateien geändert oder erstellt, die explizit durch die Codevorgaben definiert sind. Alle anderen Dateien bleiben unverändert.
	10.	Sobald alle vorgegebenen Änderungen vollständig eingearbeitet sind, wird der Vorgang beendet. Es erfolgen keine zusätzlichen, eigenen oder interpretierenden Änderungen.